# APPROOV INTEGRATION EXAMPLE

To see how a Python Flask server runs with an Approov integration please follow the
[Approov Shapes Demo Server](./docs/approov-shapes-demo-server.md) walk-through.

The concrete implementation of the Approov Shapes Demo Server is in the
[approov-protected-server.py](./server/approov-protected-server.py) file, that
is a simple Python Flask server with some endpoints protected by Approov and
other endpoints without any Approov protection.

Now let's continue reading this README for a **quick start** introduction in how
to integrate Approov on a current project by using as an example the code for
the Approov Shapes Demo Server.


## APPROOV VALIDATION PROCESS

Before we dive into the code we need to understand the Approov validation
process on the back-end side.

API calls protected by Approov will typically include a header holding an Approov
token. This token must be checked to ensure it has not expired and that it is
properly signed with the secret shared between the back-end and the Approov cloud
service.

We will use a Python package to help us in the validation of the Approov token.


## SYSTEM CLOCK

In order to correctly check for the expiration times of the Approov tokens is
very important that the Python Flask server is synchronizing automatically the
system clock over the network with an authoritative time source. In Linux this
is usual done with a NTP server.


## REQUIREMENTS

We will use Python 3 with a Flask API server to run our code.

Docker is required for the ones wanting to use the docker environment provided
by the [stack](./stack) bash script, that is a wrapper around docker commands.

Postman is the tool we recommend to be used when simulating the queries against
the API, but feel free to use any other tool of your preference.


## HOW TO USE THE DOCKER ENVIRONMENT

We recommend the use of Docker to play with the Aproov integration and you can
see how you can use it on the [Approov Shapes Demo Server](./docs/approov-shapes-demo-server.md)
walk-through, but feel free to use your local environment to play with this
Approov integration.


## HOW TO USE THE POSTMAN COLLECTION

Import this [Postman collection](https://gitlab.com/snippets/1799104/raw) that
contains all the API endpoints for the
[Approov Shapes Demo Server](./docs/approov-shapes-demo-server.md) in order to
gain a better understanding how this Approov integration works. We recommend you
to follow the demo walk-through to learn how this Postman collection is used.

The Approov tokens used in the headers  of this Postman collection where
generated by [this helper script](./server/test/helpers/generate-token.py) and
they cover all necessary scenarios, but feel free to use the script to generate
some more valid and invalid tokens, with different expire times and custom
payload claims.


## INSTALL DEPENDENCIES

If not already using the packages `pyjwt` and `python-dotenv` in your Python
Flask API project, please add them:

```bash
pip3 install pyjwt python-dotenv
```

## ORIGINAL SERVER

Let's use the [original-server.py](./server/original-server.py) as an example
for a current server where we want to add Approov to protect some or all the
endpoints and we will add to it only the necessary code to integrate Approov and
the end result can be seen in the [approov-protected-server.py](./server/approov-protected-server.py).


## HOW TO INTEGRATE

We will learn how to go from the [original-server.py](./server/original-server.py)
to the [approov-protected-server.py](./server/approov-protected-server.py) and
how to configure the server.

In order to be able to check the Approov token the `PyJWT` library needs
to know the secret used by the Approov cloud service to sign it. A secure way to
do this is by passing it as an environment variable, as it can be seen
[here](./server/approov-protected-server.py#L26).

Next we need to define two core methods to be used during the Approov token check
process. The method `_decodeApproovToken()` is to decode and simultaneously check
the token with the library `PyJWT` and the `_isValidPayloadInApproovToken()` is
to check the custom payload claim in the Approov Token. We also define some
other methods to help with the Approov integration and this are probably the
ones you may want to customize for your use case.

The custom claim is optional in the Aproov Token payload, but needs to be a
base64 encoded string from a hash of some value you want to tie up with the
Approov token. A good example is to tie up the user authentication token with
the Approov token, but your needs and requirements may be different.

Let's breakdown the implementation of the [approov-protected-server.py](./server/approov-protected-server.py) to make it easier to adapt to your
current project.


### Dependencies

We need to [require the dependencies](./server/approov-protected-server.py#L3-9)
we installed before, plus some more system dependencies:

```python
# file: server/approov-protected-server.py

# System packages
from base64 import b64decode, b64encode
from os import getenv
from hashlib import sha256

# Third part packages
import jwt
```

### Environment

If you don't have already an `.env` file, then you need to create one in the
root of your project by using this [.env.example](./.env.example) as your
starting point.

The `.env` file must contain this two variables:

```env
APPROOV_ENABLED=true
APPROOV_BASE64_SECRET=your-base64-encoded-approov-token-secret
```

Now we can read them from our code, like is done [here](./server/approov-protected-server.py#L22-28):

```python
# file: server/approov-protected-server.py


APPROOV_ENABLED = True
_approov_enabled = getenv('APPROOV_ENABLED', 'True').lower()

if _approov_enabled == 'false':
    APPROOV_ENABLED = False

APPROOV_BASE64_SECRET = getenv('APPROOV_BASE64_SECRET')
```


### Methods

Let's start by adding [this method](./server/approov-protected-server.py#L36-40)
to enable logging for Approov specific occurrences:

```python
def _logApproov(message):
    if APPROOV_ENABLED:
        log.error('APPROOV ENABLED | %s', message)
    else:
        log.info('APPROOV DISABLED | %s', message)
```

Now we need to add [this method](./server/approov-protected-server.py#L42-58) to
decode the Approv token:

```python
# file: approov-protected-server.py

def _decodeApproovToken(approov_token, approov_base64_secret):
    try:
        # Decode the approov token, allowing only the HS256 algorithm and using
        # the approov base64 encoded SECRET
        approov_token_decoded = jwt.decode(approov_token, b64decode(approov_base64_secret), algorithms=['HS256'])

        return approov_token_decoded

    except jwt.InvalidSignatureError as e:
        _logApproov('JWT TOKEN INVALID SIGNATURE: %s' % e)
        return None
    except jwt.ExpiredSignatureError as e:
        _logApproov('JWT TOKEN EXPIRED: %s' % e)
        return None
    except jwt.InvalidTokenError as e:
        _logApproov('JWT TOKEN INVALID: %s' % e)
        return None
```

Then we need [this method](./server/approov-protected-server.py#L60-76) to check
the custom payload claim in the Approov token:

```python
# file: approov-protected-server.py


def _isValidPayloadInApproovToken(approov_token_decoded, raw_payload_claim):
    if _isEmpty(approov_token_decoded):
        return False

    # checking if the approov token contains a payload and verify it.
    if 'pay' in approov_token_decoded:

        # we need to hash and base64 encode the oauth2 token in order to verify
        # it matches the same one contained in the approov token payload.
        payload_claim_hash = sha256(raw_payload_claim.encode('utf-8')).digest()
        payload_claim_base64_hash = b64encode(payload_claim_hash).decode('utf-8')

        return approov_token_decoded['pay'] == payload_claim_base64_hash

    # The Approov failover running in the Google cloud doesn't return the custom
    # payload claim, thus we always need to have a pass when is not present.
    return True
```

We also need to add [this method](./server/approov-protected-server.py#L78-82)
to handle requests with an invalid Approov token:

```python
def _abortApproovProtectedRequest(message):
    _logApproov(message)

    if APPROOV_ENABLED:
        abort(make_response(jsonify({}), 400))
```

Now we need to add [this method](./server/approov-protected-server.py#L84-95)
to trigger the Approov token check in each endpoint we want to protect:

```python
def _checkApproovToken():
    approov_token = _getHeader('approov-token')

    if _isEmpty(approov_token):
        _abortApproovProtectedRequest('APPROOV TOKEN EMPTY')

    approov_token_decoded = _decodeApproovToken(approov_token, APPROOV_BASE64_SECRET)

    if _isEmpty(approov_token_decoded):
        _abortApproovProtectedRequest('FAILED TO DECODE APPROOV TOKEN')

    return approov_token_decoded
```

Finally we add [this method](./server/approov-protected-server.py#L97-108)
to trigger the Approov token check, with a custom payload claim, in each endpoint
we want to protect:

```python
def _checkApproovTokenWithCustomPayloadClaim(custom_payload_claim):

    approov_token_decoded = _checkApproovToken()

    # We will check that the OAUTH2 Token included by the mobile app in the
    # Approov Token payload is the same that was sent in the header of the request.
    #
    # On failure it means the request was tampered with, therefore is rejected.
    if not _isValidPayloadInApproovToken(approov_token_decoded, custom_payload_claim):
        _abortApproovProtectedRequest('APPROOV TOKEN WITH INVALID PAYLOAD')

    return approov_token_decoded
```

#### Endpoints

To protect specific endpoints in a current server we only need to add the Approov
token check for each endpoint we want to protect, as we have done in the
[shapes](./server/approov-protected-server.py#L125-126) endpoint:

```python
# file: approov-protected-server.py

# check if the Approov token is valid and aborts the request if not.
_checkApproovToken(oauth2_token)
```

or if using the custom payload claim in the Approov token, as we have done in
the [forms](./server/approov-protected-server.py#L146-148) endpoint:

```python
# file: approov-protected-server.py

# check if the Approov token and the custom payload claim(the ouath2 token)
# are valid and aborts the request if not.
_checkApproovTokenWithCustomPayloadClaim(oauth2_token)
```

#### The Difference

If we compare the [original-server.py](./server/original-server.py) with the
[approov-protected-server.py](./server/approov-protected-server.py) we will see
this file difference:

```python
--- /home/sublime/workspace/python/flask/server/original-server.py
+++ /home/sublime/workspace/python/flask/server/approov-protected-server.py
@@ -1,8 +1,12 @@
 # System packages
 import logging
+from base64 import b64decode, b64encode
+from os import getenv
+from hashlib import sha256
 from random import choice

 # Third part packages
+import jwt
 from dotenv import load_dotenv, find_dotenv
 from flask import Flask, request, abort, make_response, jsonify

@@ -15,11 +19,93 @@

 HTTP_PORT = int(getenv('HTTP_PORT', 5000))

+APPROOV_ENABLED = True
+_approov_enabled = getenv('APPROOV_ENABLED', 'True').lower()
+
+if _approov_enabled == 'false':
+    APPROOV_ENABLED = False
+
+APPROOV_BASE64_SECRET = getenv('APPROOV_BASE64_SECRET')
+
 def _getHeader(key, default_value = None):
     return request.headers.get(key, default_value)

 def _isEmpty(token):
     return token is None or token == ""
+
+def _logApproov(message):
+    if APPROOV_ENABLED:
+        log.error('APPROOV ENABLED | %s', message)
+    else:
+        log.info('APPROOV DISABLED | %s', message)
+
+def _decodeApproovToken(approov_token, approov_base64_secret):
+    try:
+        # Decode the approov token, allowing only the HS256 algorithm and using
+        # the approov base64 encoded SECRET
+        approov_token_decoded = jwt.decode(approov_token, b64decode(approov_base64_secret), algorithms=['HS256'])
+
+        return approov_token_decoded
+
+    except jwt.InvalidSignatureError as e:
+        _logApproov('JWT TOKEN INVALID SIGNATURE: %s' % e)
+        return None
+    except jwt.ExpiredSignatureError as e:
+        _logApproov('JWT TOKEN EXPIRED: %s' % e)
+        return None
+    except jwt.InvalidTokenError as e:
+        _logApproov('JWT TOKEN INVALID: %s' % e)
+        return None
+
+def _isValidPayloadInApproovToken(approov_token_decoded, custom_payload_claim):
+    if _isEmpty(approov_token_decoded):
+        return False
+
+    # checking if the approov token contains a payload and verify it.
+    if 'pay' in approov_token_decoded:
+
+        # we need to hash and base64 encode the oauth2 token in order to verify
+        # it matches the same one contained in the approov token payload.
+        payload_claim_hash = sha256(custom_payload_claim.encode('utf-8')).digest()
+        payload_claim_base64_hash = b64encode(payload_claim_hash).decode('utf-8')
+
+        return approov_token_decoded['pay'] == payload_claim_base64_hash
+
+    # The Approov failover running in the Google cloud doesn't return the custom
+    # payload claim, thus we always need to have a pass when is not present.
+    return True
+
+def _abortApproovProtectedRequest(message):
+    _logApproov(message)
+
+    if APPROOV_ENABLED:
+        abort(make_response(jsonify({}), 400))
+
+def _checkApproovToken():
+    approov_token = _getHeader('approov-token')
+
+    if _isEmpty(approov_token):
+        _abortApproovProtectedRequest('APPROOV TOKEN EMPTY')
+
+    approov_token_decoded = _decodeApproovToken(approov_token, APPROOV_BASE64_SECRET)
+
+    if _isEmpty(approov_token_decoded):
+        _abortApproovProtectedRequest('FAILED TO DECODE APPROOV TOKEN')
+
+    return approov_token_decoded
+
+def _checkApproovTokenWithCustomPayloadClaim(custom_payload_claim):
+
+    approov_token_decoded = _checkApproovToken()
+
+    # We will check that the OAUTH2 Token included by the mobile app in the
+    # Approov Token payload is the same that was sent in the header of the request.
+    #
+    # On failure it means the request was tampered with, therefore is rejected.
+    if not _isValidPayloadInApproovToken(approov_token_decoded, custom_payload_claim):
+        _abortApproovProtectedRequest('APPROOV TOKEN WITH INVALID PAYLOAD')
+
+    return approov_token_decoded

 @api.route("/")
 def endpoints():
@@ -35,6 +121,10 @@

 @api.route("/shapes")
 def shapes():
+
+    # checkd if the Approov token is valid and aborts the request if not.
+    _checkApproovToken()
+
     shape = choice([
         "Circle",
         "Triangle",
@@ -46,11 +136,16 @@

 @api.route("/forms")
 def forms():
+
     oauth2_token = _getHeader("oauth2-token")

     if _isEmpty(oauth2_token):
         log.error('OAUTH2 TOKEN EMPTY')
         abort(make_response(jsonify({}), 400))
+
+    # check if the Approov token and the custom payload claim(the ouath2 token)
+    # are valid and aborts the request if not.
+    _checkApproovTokenWithCustomPayloadClaim(oauth2_token)

     # Now we can handle OAUTH2 as we usually would do in a Python Flask API.
     # Maybe like in https://auth0.com/docs/quickstart/webapp/python/
```

As we can see the Approov integration in a current server is simple, easy and is
done with just a few lines of code.

If you have not done it already, now is time to follow the
[Approov Shapes Demo Server](./docs/approov-shapes-demo-server.md) walk-through
to see and have a feel for how all this works.


## PRODUCTION

In order to protect the communication between your mobile app and the API server
is important to only communicate hover a secure communication channel, aka https.

Please bear in mind that https on its own is not enough, certificate pinning
must be also used to pin the connection between the mobile app and the API
server in order to prevent [Man in the Middle Attacks](https://approov.io/docs/mitm-detection.html).

We do not use https and certificate pinning in this Approov integration example
because we want to be able to run the
[Approov Shapes Demo Server](./docs/approov-shapes-demo-server.md) in localhost.

However in production will be mandatory to implement at least
[static pinning](https://approov.io/docs/mitm-detection.html#id1)
or [dynamic pinning](https://approov.io/docs/mitm-detection.html#dynamic-pinning).
